#!/usr/bin/env bash
# basin - all the streams you care about in once place
# by BrowncoatShadow and Crendgrim
# https://github.com/BrowncoatShadow/basin
shopt -s extglob

# Initial default configuration.
CONFIG_FILE="${HOME}/.config/basin.json"
CONFIG_STRUCTURE='{
  "check_interval": { "type": "number", "default": 1, "description": "How often basin runs the online check (in minutes) when installed via cron" },
  "database": { "type": "string", "default": "'"${HOME}"'/.local/share/basin/online.json" },
  "service": { "type": "object", "description": "Configure the service providers", "content": {
    "twitch": { "type": "object", "description": "Configure Twitch", "content": {
      "enabled": { "type": "boolean", "default": false, "description": "Whether this service gets called at all" },
      "client_id": { "type": "string", "default": "", "description": "A Twitch API Client-ID is required for all calls to the Twitch API. Generate it at < https://www.twitch.tv/kraken/oauth2/clients/new >." },
      "user": { "type": "string", "default": "", "description": "Your username on Twitch. basin will get the list of your followed channels and check these." },
      "follow": { "type": "array-string", "default": [], "description": "A list of Twitch channels to follow" }
    } },
    "hitbox": { "type": "object", "description": "Configure Hitbox", "content": {
      "enabled": { "type": "boolean", "default": false, "description": "Whether this service gets called at all" },
      "user": { "type": "string", "default": "", "description": "Your username on Hitbox. basin will get the list of your followed channels and check these." },
      "follow": { "type": "array-string", "default": [], "description": "A list of Hitbox channels to follow" }
    } },
    "azubu": { "type": "object", "description": "Configure Azubu", "content": {
      "enabled": { "type": "boolean", "default": false, "description": "Whether this service gets called at all" },
      "follow": { "type": "array-string", "default": [], "description": "A list of Azubu channels to follow" }
    } },
    "periscope": { "type": "object", "description": "Configure Periscope", "content": {
      "enabled": { "type": "boolean", "default": false, "description": "Whether this service gets called at all" },
      "follow": { "type": "array-string", "default": [], "description": "A list of Periscope channels to follow" }
    } },
    "youtube": { "type": "object", "description": "Configure YouTube", "content": {
      "enabled": { "type": "boolean", "default": false, "description": "Whether this service gets called at all" },
      "key": { "type": "string", "default": "", "description": "A YouTube API key is required for all calls to the YouTube API." },
      "follow": { "type": "array-string", "default": [], "description": "A list of YouTube channels to follow" }
    } }
  } },
  "notifier": { "type": "object", "description": "Configure notifier modules", "content": {
    "pushbullet": { "type": "object", "description": "Configure PushBullet", "content": {
      "enabled": { "type": "boolean", "default": false, "description": "Whether this notifier gets called" },
      "token": { "type": "string", "default": "", "description":  "Your PushBullet token" },
      "target": { "type": "array-string", "default": [], "description": "A list of targets to push the notification to" }
    } },
    "kdialog": { "type": "object", "description": "Configure KDialog (Plasma) notifications", "content": {
      "enabled": { "type": "boolean", "default": false, "description": "Whether this notifier gets called" }
    } },
    "osx": { "type": "object", "description": "Configure OSX notifications", "content": {
      "enabled": { "type": "boolean", "default": false, "description": "Whether this notifier gets called" }
    } },
    "terminal_notifier": { "type": "object", "description": "Configure terminal notifier", "content": {
      "enabled": { "type": "boolean", "default": false, "description": "Whether this notifier gets called" }
    } }
  } }
}'

### Helper Functions
check_system() { # platform specific fixes and function definitions
  local system_type
  system_type="$(uname)"
  if [[ "${system_type}" == "Darwin" ]]; then # OS X
    # add jq's install dir (via homebrew) to PATH.
    PATH=${PATH}:/usr/local/bin
    # helper for interactive mode, returns the given time using system's `date`
    system_date() { echo "$(date -jf %s "${1}" "+%H:%M"))"; }
  elif [[ "${system_type}" == "Linux" ]]; then # Linux
    system_date() { echo "$(date --date="@${1}" "+%H:%M"))"; }
  else # unknown system
    error "${system_type} is not supported."
    exit 1
  fi
}
error() { # print a colorful message to STDERR
  local red='\033[0;31m'
  local nc='\033[0m'
  echo -e "${red}[ERROR] ${1}${nc}" >&2
}
depends_on() { # check for a given dependency, exit if missing
  command -v ${1} > /dev/null
  if [[ "$?" == "1" ]]; then
    error "Missing dependency: ${1}"
    exit 1
  fi
}
check_file() { # generate given folders and files if they do not exist
  if [[ ! -f ${1} ]]; then
    mkdir -p $(dirname ${1})
    touch "${1}"
  fi
  if [[ -z "$(cat ${1})" ]]; then
    ${2} > "${1}"
  fi
}
json_get() { # get channel data from an array of channel objects
  echo "${1}" | jq -r '.[] | select(.name=="'${2}'") | .'${3}
}
chan_get() { # get a value from a channel object
  echo "${1}" | jq -r ".${2} | select(.!=null)"
}
playing_check() { # return null if given game is null, return given "playing" string if it is not
  if [[ -n "${1}" ]]; then
    echo "${2}"
  fi
}
preflight() { # handles all common tasks that should be taken before normal operations
  check_system
  config::load
  database::load
}

### Crontab
# Functions that manage basin's crontab entry.
crontab::running() { # check if entry already exists in crontab
  depends_on crontab

  # this can be fooled by basin's entry being commented out
  if crontab -l 2> /dev/null | grep -Fq 'basin check'; then
    true
  else
    false
  fi
}
crontab::status() { # prints basin's status to terminal
  if crontab::running; then
    echo "Basin is running."
  else
    echo "Basin is not running."
  fi
}
crontab::start() { # create basin's crontab entry
  local check_interval
  if [[ "${1}" ]]; then
    check_interval="${1}"
  else
    config::load # no preflight so manually load config first
    check_interval="$(config::get .check_interval)"
  fi

  if crontab::running; then
    error "Basin is already running."
    exit 1
  fi
  if [[ ! "${check_interval}" =~ ^[0-9]+$ || "${check_interval}" -lt 1  ]]; then
    error "Argument for 'start' needs to be a number of minutes, greater than 1."
    exit 1
  fi

  local source_dir
  source_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
  local entry="*/${check_interval} * * * * ${source_dir}/basin check >/dev/null 2>&1"

  # list crontab, concat that output with basin's entry, feed back to crontab
  EDITOR=cat crontab -e 2> /dev/null | { cat; echo "${entry}"; } | crontab -
}
crontab::stop() { # remove basin's crontab entry
  if ! crontab::running; then
    return
  fi

  # list crontab, remove basin's entry, feed back to crontab
  EDITOR=cat crontab -e 2> /dev/null | sed '/basin check/d' | crontab -
}

### Config
# Functions that manage configuration.
config::load() { # load the configuration and create it if it does not exist
  if [[ "${ALT_CONFIG}" ]]; then
    CONFIG_FILE="${ALT_CONFIG}"
  fi
  check_file "${CONFIG_FILE}" "config::generate"
  CONFIG="$(cat "${CONFIG_FILE}")"
}
config::generate() { # generate a blank configuration
  config::_gen "${CONFIG_STRUCTURE}" | jq '.'
}
config::_gen() { # recursively generate the configuration

  echo "{"

  local keys="$(echo "${1}" | jq -r 'keys[]')"
  local first=true
  local type description default
  for key in ${keys}; do
    if [[ "${first}" == "true" ]]; then
      first=false
    else
      echo ","
    fi
    type="$(echo "${1}" | jq -r ".${key}.type")"
    description="$(echo "${1}" | jq -r ".${key}.description // \"\"")"
    default="$(echo "${1}" | jq -r ".${key}.default")"
    case "${type}" in
      object)
        echo "\"${key}\":"
        config::_gen "$(echo "${1}" | jq ".${key}.content // {}")"
        ;;
      array-*|number|boolean)
        echo "\"${key}\": ${default}"
        ;;
      *)
        echo "\"${key}\": \"${default}\""
    esac
  done

  echo "}"

}
config::key_type() { # return the type class of a configuration key
  local path
  path="$(config::default_path "${1}")"
  [[ $? -ne 0 ]] && exit 1

  echo "$(echo "${CONFIG_STRUCTURE}" | jq -r "${path}.type // null")"
}
config::default_path() { # get the path to the specification for a key
  if [[ -z "${1}" ]]; then
    return # no value given
  fi

  local path type
  local no_child=false
  IFS='.' read -ra keys <<< "${1:1}"
  for child in "${keys[@]}"; do
    if [[ "${no_child}" == "true" ]]; then
      error "Configuration key ${1} not found!"
      exit 1
    fi
    path="${path}.${child}"
    type="$(echo "${CONFIG_STRUCTURE}" | jq -r "${path}.type // null")"
    if [[ "${type}" == "object" ]]; then
      path="${path}.content"
    else
      no_child=true
    fi
  done

  if [[ "${type}" == "null" ]]; then
    error "Configuration key ${1} not found!"
    exit 1
  fi

  echo "${path}"

}
config::enabled_keys() { # list services or notifiers that are enabled
  local possible_enabled user_enabled
  possible_enabled="$(echo "${CONFIG_STRUCTURE}" | jq -r "${1}.content | keys")"
  user_enabled="$(echo "${CONFIG}" | jq -r "[${1} | to_entries[] | select(.value.enabled == true) .key]")"
  # Make sure the user has not "enabled" any items in their config that are not
  # actually supported, by checking against the keys in the default config.
  echo "${possible_enabled}" | jq -r ". - (. - ${user_enabled}) | .[] | tostring"
}
config::get() { # print the value of a key
  local type
  type="$(config::key_type "${1}")"
  [[ $? -ne 0 ]] && exit 1
  if [[ "${type}" == "array-string" ]]; then
    echo "${CONFIG}" | jq -r "${1} | .[] | tostring"
  else
    echo "${CONFIG}" | jq -r "${1}"
  fi
}
config::set() { # set the value of a key
  local type value
  type="$(config::key_type "${1}")"
  [[ $? -ne 0 ]] && exit 1

  case "${type}" in
    object|array-*)
      error "Cannot set object or array ${1}!"
      exit 1
      ;;
    string)
      value="\"${2}\""
      ;;
    number)
      if [[ ${2} =~ ^[0-9]+$ ]]; then
        value="${2}"
      else
        error "Wrong input for ${1}: expected number"
        exit 1
      fi
      ;;
    boolean)
      if [[ ${2} =~ ^(true|false)$ ]]; then
        value="${2}"
      else
        error "Wrong input for ${1}: expected boolean"
        exit 1
      fi
      ;;
    *)
      error "Unexpected error: datatype ${type} for ${1} not known!"
      exit 1
  esac

  CONFIG="$(echo "${CONFIG}" | jq "${1} = ${value}")"
  echo "${CONFIG}" > "${CONFIG_FILE}"
}
config::mod_array() { # add or remove items from a given key that is an array
  local mod="${1}"
  local key="${2}"
  shift 2

  local type
  type="$(config::key_type "${key}")"
  [[ $? -ne 0 ]] && exit 1

  if [[ "${type}" == "array-string" ]]; then
    for item in "${@}"; do
      CONFIG="$(echo "${CONFIG}" | jq "${key} |= (. ${mod} [\"${item}\"] | unique)")"
    done
  else
    error "${key} is not an array."
    exit 1
  fi

  echo "${CONFIG}" > "${CONFIG_FILE}"
}
config::reset() { # reset a key to its default value
  local path
  path="$(config::default_path "${1}")"
  [[ $? -ne 0 ]] && exit 1

  local value="$(echo "${CONFIG_STRUCTURE}" | jq -r "${path}.default")"
  if [[ -z "${value}" ]]; then
    error "Found no default value for ${1}!"
  else
    config::set "${1}" "${value}"
  fi
}
config::do () { # handle the 'config' command
  config::load
  case ${1} in
    get) shift; config::get "${@}" ;;
    set) shift; config::set "${@}" ;;
    add) shift; config::mod_array + "${@}" ;;
    remove) shift; config::mod_array - "${@}" ;;
    reset) shift; config::reset "${@}" ;;
    *) error "${1} is not a supported config action."; exit 1 ;;
  esac
}

### Database
# Functions that handle the local database.
database::load() { # makes sure the DB file exists and is not too old
  DATABASE_FILE="$(config::get .database)"

  check_file "${DATABASE_FILE}" "echo {}"
  # cleanup: if the database file is older than 2 hours, consider it outdated
  # and remove its contents
  [[ -s "${DATABASE_FILE}" && $(($(date +%s)-$(cat "${DATABASE_FILE}" | jq -r '.lastcheck // 0'))) -gt 7200 ]] && database::reset
}
database::get() { # get data from the database
  cat "${DATABASE_FILE}" \
    | jq -r '(.online // [])[] | select(.service=="'${1}'" and .name=="'${2}'") | .'${3}
}
database::include() { # add arrayed online channel objects to global list to be added to db
  # update the global with entries if they exist
  if [[ -n "${1}" ]]; then
    new_online_db="$(echo "${new_online_db}" | jq ". + ${1}")"
  fi
}
database::write() { # save given json object to the DATABASE_FILE
  if [[ -n "${DATABASE_FILE}" ]]; then
    echo "${1}" \
      | jq '{online: ., lastcheck: '$(date +%s)'}' > ${DATABASE_FILE}
  fi
}
database::recover() { # recover an existing DB entry for broken API results
  local service="${1}"
  local json="${2}"
  local channel="${3}"
  # recover existing db entry if it exists
  local recovered_data
  recovered_data="$(database::get "${service}" ${channel})"
  if [[ -n "${recovered_data}" ]]; then
    # remove entry
    json="$(echo "${json}" \
      | jq 'del(.[] | select(.name=="'${channel}'"))')"
    # return a fixed JSON object
    echo "${json}" | jq '. + ['"${recovered_data}"']'
  else
    echo "${json}"
  fi
}
database::reset() { # wipes the database clean
  DATABASE_FILE="$(config::get .database)"
  echo "{}" > "${DATABASE_FILE}"
}
database::print_formatted() { # pretty-prints the database
  echo -e "$(cat "${DATABASE_FILE}" | jq -r '
    (.online // [])[] |
      [
        "\n\\033[1;34m", .display_name, "\\033[0m",
        (
          # Properly align the game for shorter channel names
          .display_name | length |
          if . < 8 then
            "\t\t"
          else
            "\t"
          end
        ),
        "\\033[0;36m", .game, "\\033[0m",
        "\n\\033[0;32m", .url, "\\033[0m",
      "\n", .status
      ] |
    add')"
}

### Notifier Plugins
# Plugins that provide user-visible notifications.
notifier::echo() { # notify by printing to STDOUT in the terminal
  local service display_name game status url playing
  service="$(chan_get "${1}" 'service')"
  display_name="$(chan_get "${1}" 'display_name')"
  status="$(chan_get "${1}" 'status')"
  url="$(chan_get "${1}" 'url')"
  game="$(chan_get "${1}" 'game')"
  playing="$(playing_check "${game}" " playing ${game}")"

  echo "${service} | ${display_name}${playing} | ${status} | ${url}"
}
notifier::kdialog() { # notify by KDialog popup
  local service display_name game status
  service="$(chan_get "${1}" 'service')"
  display_name="$(chan_get "${1}" 'display_name')"
  status="$(chan_get "${1}" 'status')"
  game="$(chan_get "${1}" 'game')"
  playing="$(playing_check "${game}" " playing <b>${game}</b>")"

  display="$DISPLAY"
  if [[ -z "$display" ]]; then display=":0"; fi
  DISPLAY="$display" kdialog \
    --title "${service}" \
    --icon "video-player" \
    --passivepopup "<b>${display_name}</b>${playing}<br>${status}"
}
notifier::osx() { # OS X Notification Center with applescript
  local service display_name game status
  service="$(chan_get "${1}" 'service')"
  display_name="$(chan_get "${1}" 'display_name')"
  status="$(chan_get "${1}" 'status')"
  game="$(chan_get "${1}" 'game')"
  playing="$(playing_check "${game}" " playing ${game}")"

  osascript \
    -e "display notification \"${status}\" \
    with title \"${service}\" \
    subtitle \"${display_name}${playing}\""
}
notifier::terminal_notifier() { # OS X Notification Center with terminal-notifier
  local service display_name game status url
  service="$(chan_get "${1}" 'service')"
  service_logo="$(chan_get "${1}" 'service_logo')"
  logo="$(chan_get "${1}" 'logo')"
  display_name="$(chan_get "${1}" 'display_name')"
  status="$(chan_get "${1}" 'status')"
  url="$(chan_get "${1}" 'url')"
  game="$(chan_get "${1}" 'game')"
  playing="$(playing_check "${game}" " playing ${game}")"

  tn_sanitize() { # escape characters known to cause issues at the beginning of strings
    local escape='[<'
    echo "${1}" | sed "s/^[${escape}]/\\\&/"
  }

  terminal-notifier \
    -title "${service}" \
    -subtitle "${display_name}${playing}" \
    -message "$(tn_sanitize "${status}")" \
    -appIcon "${service_logo}" \
    -contentImage "${logo}" \
    -open "${url}" \
    >/dev/null # silently fail instead of printing Usage
}
notifier::pushbullet() { # notify by PushBullet API notification
  local pushbullet_token pushbullet_targets
  pushbullet_token="$(config::get .notifier.pushbullet.token)"
  pushbullet_targets="$(config::get .notifier.pushbullet.target)"

  if [[ -z "${pushbullet_token}" ]]; then
    error "Missing configuration key: .notifier.pushbullet.token"
    return 1
  fi

  local service display_name game status url
  service="$(chan_get "${1}" 'service')"
  display_name="$(chan_get "${1}" 'display_name')"
  status="$(chan_get "${1}" 'status')"
  url="$(chan_get "${1}" 'url')"
  game="$(chan_get "${1}" 'game')"
  playing="$(playing_check "${game}" " playing ${game}")"

  push() {
    local data
    data='{
      "device_iden": "'"${1}"'",
      "type": "link",
      "title": "'"${service}"'",
      "body": "'"${display_name}${playing}\\n${status}"'",
      "url": "'"${url}"'"
    }'
    curl -s \
      -X POST https://api.pushbullet.com/v2/pushes \
      --header 'Access-Token: '${pushbullet_token}'' \
      --header 'Content-Type: application/json' \
      --data-binary "${data}" \
      > /dev/null
  }

  # push to any targets that are defined
  if [[ -n "${pushbullet_targets}" ]]; then
    for target in ${pushbullet_targets}; do
      push ${target}
    done
  else # if no targets, push to all
    push
  fi
}

### Service Plugins
# Plugins that provide support for a particular streaming service.
service::twitch() { # https://www.twitch.tv/
  local twitch_client_id twitch_user twitch_follow
  twitch_client_id="$(config::get .service.twitch.client_id)"
  twitch_user="$(config::get .service.twitch.user)"
  twitch_follow="$(config::get .service.twitch.follow)"

  if [[ -z "${twitch_client_id}" ]]; then
    error "Missing configuration key: .service.twitch.client_id"
    return 1
  fi
  if [[ -z "${twitch_user}" && -z "${twitch_follow}" ]]; then
    error "Missing configuration key: .service.twitch.user AND/OR .service.twitch.follow"
    return 1
  fi

  # begin the master list of channels to check
  local twitch_list=${twitch_follow}

  # if user is set, fetch user's follow list and add them to the list
  if [[ -n ${twitch_user} ]]; then 
    twitch_list="${twitch_list} \
      "$(curl -s \
      --header 'Client-ID: '${twitch_client_id} \
      -H 'Accept: application/vnd.twitchtv.v3+json' \
      -X GET "https://api.twitch.tv/kraken/users/${twitch_user}/follows/channels?limit=100" \
      | jq -r '.follows[] | .channel.name' \
      | tr '\n' ' ')
  fi

  # remove duplicates from the list
  twitch_list=$(echo $(printf '%s\n' ${twitch_list} | sort -u))

  # sanitize the list for the fetch url
  local url_list
  url_list="$(echo ${twitch_list} | sed 's/ /\,/g')"

  # fetch the json for all followed channels
  local returned_data
  returned_data="$(curl -s \
    --header 'Client-ID: '${CLIENT} \
    -H 'Accept: application/vnd.twitchtv.v3+json' \
    -X GET "https://api.twitch.tv/kraken/streams?channel=${url_list}&limit=100")"

  # create new database
  local new_online_json
  new_online_json="$(echo "${returned_data}" | jq '
    [
      .streams[] |
        {
          service: "Twitch",
          service_logo: "http://s.jtvnw.net/jtv_user_pictures/hosted_images/GlitchIcon_WhiteonPurple.png",
          name: .channel.name,
          display_name: .channel.display_name,
          game: .channel.game,
          status: .channel.status,
          url: .channel.url,
          logo: .channel.logo
        }
    ]')"

  # notify for new streams
  for channel in ${twitch_list}; do
    # sometimes, the api sends broken results handle these gracefully
    local check_game check_status
    check_game="$(json_get "${new_online_json}" "${channel}" 'game')"
    check_status="$(json_get "${new_online_json}" "${channel}" 'status')"
    if [[ "${check_game}" == null && "${check_status}" == null ]]; then
      # if the stream was live before, assume the results to be broken, so we
      # don't re-notify
      if [[ -n "${DATABASE_FILE}" ]]; then
        # recover existing db entry if it exists
        new_online_json="$(database::recover "${service}" "${new_online_json}" "${channel}")"
      fi
      # otherwise ignore the broken result to not get a null/null notification
      continue
    fi

    # if result is not broken, send it to notifier gateway
    basin::notify "${new_online_json}" "${channel}"
  done

  database::include "${new_online_json}"
}
service::hitbox() { # http://www.hitbox.tv/
  local hitbox_user hitbox_follow
  hitbox_user="$(config::get .service.hitbox.user)"
  hitbox_follow="$(config::get .service.hitbox.follow)"

  if [[ -z "${hitbox_user}" && -z "${hitbox_follow}" ]]; then
    error "Missing configuration key: .service.hitbox.user AND/OR .service.hitbox.follow"
    return 1
  fi

  # use the specified followlist, if set
  local hitbox_list="${hitbox_follow}"
  # if user is set, fetch user's follow list and add them to the list
  if [[ -n "${hitbox_user}" ]]; then
    hitbox_list="${hitbox_list} \
    "$(curl -s \
    -X GET "https://api.hitbox.tv/following/user/?user_name=${hitbox_user}" \
    | jq -r '.following[] | .user_name' \
    | tr '\n' ' ')
  fi

  # remove duplicates from the list
  hitbox_list=$(echo $(printf '%s\n' ${hitbox_list} | sort -u))

  # fetch the json for all followed channels
  local new_online_json='[]'
  for channel in ${hitbox_list}; do
    local returned_data
    returned_data="$(curl -s -X GET "https://api.hitbox.tv/media/live/${channel}")"

    # sometimes the hitbox api returns garbage if that happens, handle it gracefully
    local is_live
    is_live="$(echo "${returned_data}" \
      | jq -r '.livestream[] | .media_is_live' \
      2>/dev/null)"

    if [[ $? == 4 ]]; then
      # insert entry recovered from database
      if [[ -n "${DATABASE_FILE}" ]]; then
        # recover existing db entry if it exists
        new_online_json="$(database::recover "${service}" "${new_online_json}" "${channel}")"
      fi

    elif [[ "${is_live}" == "1" ]]; then
      # insert into new database
      new_online_json="$(echo "${returned_data}" \
        | jq "${new_online_json}"' +
        [
          .livestream[] |
          {
            service: "Hitbox",
            service_logo: "http://i.imgur.com/ogo74T5.png",
            name: .media_name,
            display_name: .media_display_name,
            game: .category_name,
            status: .media_status,
            url: .channel.channel_link,
            logo: ("http://edge.sf.hitbox.tv" + .channel.user_logo)
          }
        ]')"
    fi
  done

  # notify for new streams
  for channel in ${hitbox_list}; do
    basin::notify "${new_online_json}" ${channel,,}
  done

  database::include "${new_online_json}"
}
service::azubu() { # http://www.azubu.tv/
  local azubu_follow
  azubu_follow="$(config::get .service.azubu.follow)"

  if [[ -z "${azubu_follow}" ]]; then
    error "Missing configuration key: .service.azubu.follow"
    return 1
  fi

  # remove duplicates from the list
  local azubu_list
  azubu_list=$(echo $(printf '%s\n' ${azubu_follow} | sort -u))
  # sanitize the list for the fetch url
  local url_list
  url_list=$(echo ${azubu_list} | sed 's/ /\,/g')
  # fetch the json for all followed channels
  local returned_data
  returned_data="$(curl -s \
    -X GET "http://api.azubu.tv/public/channel/list?channels=${url_list}")"

  # create new database
  local new_online_json
  new_online_json="$(echo "${returned_data}" \
    | jq '
    [
      .data [] |
      select(.is_live == true) |
      {
        service: "Azubu",
        service_logo: "http://cdn.content.azubu.tv.s3.amazonaws.com/assets/images/azubu_placeholder.png",
        name: .user.username,
        display_name: .user.display_name,
        game: .category.title,
        status: .title,
        url: .url_channel,
        logo: .user.profile.url_photo_large
      }
    ]')"

  # notify for new streams
  for channel in ${azubu_list}; do
    basin::notify "${new_online_json}" ${channel}
  done

  database::include "${new_online_json}"
}
service::periscope() { # https://www.periscope.tv/
  local periscope_follow
  periscope_follow="$(config::get .service.periscope.follow)"

  if [[ -z "${periscope_follow}" ]]; then
    error "Missing configuration key: .service.periscope.follow"
    return 1
  fi

  # remove duplicates from the list
  periscope_follow=$(echo $(printf '%s\n' ${periscope_follow} | sort -u))

  local new_online_json='[]'
  for channel in ${periscope_follow}; do

    local raw_html
    raw_html="$(curl -s https://www.periscope.tv/${channel})"
    # Periscope's API is private. However, user pages have a meta tag with an
    # HTML entity-encoded JSON string that contains everything we want to know.
    # After fetching the user page, we have to get everything in the
    # broadcast-data meta tag's value, then decode the HTML entities we know it
    # commonly uses. End result: a JSON string we would expect from an API.
    local broadcast_data
    broadcast_data="$(echo "${raw_html}" \
      | sed -n 's/.*meta id=\"broadcast-data\" content=\"\(.*\)"><meta id=\"broadcast-in-app\".*/\1/p' \
      | sed -e 's/\&quot;/"/g' \
            -e 's/\&amp;/\&/g' )"

    # check if the channel is broadcasting
    local is_running
    is_running="$(echo ${broadcast_data} \
      | jq 'select(.broadcast.state=="RUNNING")' 2>/dev/null)"
    if [[ -n "${is_running}" ]]; then
      new_online_json="$(echo "${broadcast_data}" \
        | jq "${new_online_json}"' +
        [
          .broadcast |
          {
            service: "Periscope",
            service_logo: "https://www.periscope.tv/v/images/press_assets/largeicon.png",
            name: .username,
            display_name: .user_display_name,
            game: .class_name,
            status: .status,
            url: ("https://www.periscope.tv/" + .username),
            logo: .profile_image_url
          }
        ]')"
    fi
  done

  # notify for new streams
  for channel in ${periscope_follow}; do
    basin::notify "${new_online_json}" ${channel}
  done

  database::include "${new_online_json}"
}
service::youtube() { # https://www.youtube.com/
  local youtube_key youtube_follow
  youtube_key="$(config::get .service.youtube.key)"
  youtube_follow="$(config::get .service.youtube.follow)"

  if [[ -z "${youtube_key}" ]]; then
    error "Missing configuration key: .service.youtube.key"
    return 1
  fi
  if [[ -z "${youtube_follow}" ]]; then
    error "Missing configuration key: .service.youtube.follow"
    return 1
  fi

  # remove duplicates from the list
  youtube_follow=$(echo $(printf '%s\n' ${youtube_follow} | sort -u))

  # define some api url strings
  local yt_api="https://www.googleapis.com/youtube/v3/"
  local yt_user_search="${yt_api}channels?part=snippet&key=${youtube_key}&forUsername="
  local yt_live_search="${yt_api}search?part=snippet&eventType=live&type=video&key=${youtube_key}&channelId="

  local new_online_json='[]'
  for channel in ${youtube_follow}; do
    # get the channel id for a youtube user
    local user_data="$(curl -s -X GET ${yt_user_search}${channel})"
    local chan_id
    chan_id="$(echo "${user_data}" | jq -r '.items[0].id')"

    local broadcast_data
    broadcast_data="$(curl -s -X GET ${yt_live_search}${chan_id})"

    # check if the channel is broadcasting
    local broadcast_status
    broadcast_status="$(echo ${broadcast_data} \
      | jq -r '.items[0].snippet.liveBroadcastContent' 2>/dev/null)"
    if [[ "${broadcast_status}" == "live" ]]; then
      local chan_logo
      chan_logo="$(echo "${user_data}" | jq -r '.items[0].snippet.thumbnails.high.url')"
      new_online_json="$(echo "${broadcast_data}" \
        | jq "${new_online_json}"' +
        [
          .items[0] |
          {
            service: "YouTube",
            service_logo: "https://www.youtube.com/yt/brand/media/image/YouTube-icon-full_color.png",
            name: "'"${channel}"'",
            display_name: .snippet.channelTitle,
            status: .snippet.title,
            url: ("https://www.youtube.com/watch?v=" + .id.videoId),
            logo: "'"${chan_logo}"'"
          }
        ]')"
    fi
  done

  # notify for new streams
  for channel in ${youtube_follow}; do
    basin::notify "${new_online_json}" ${channel}
  done

  database::include "${new_online_json}"
}

### Basin Core
# The core functionality for basin.
basin::help() { # be helpful
  local arg="${1}"
  [[ -z "${arg}" ]] && arg=usage
  case "${arg}" in
    help)
      cat <<HELP
Usage:
  basin help [command]

Description:
  Help will describe commands and how they can be used.

See Also:
  usage
HELP
      ;;
    config)
      cat <<CONFIG
Usage:
  basin config <action> [key] [value]

Description:
  Gets and sets configuration values in the configuration file.

Actions:
  get [key]
        Gets the value of a given key. If no key is given, it will print the
        whole config.
  set <key> <value>
        Sets the given key to the given value.
  reset <key>
        Resets the given key to its default value.
  add <key> <value>
        Adds the given value to the key which is an array.
  remove <key> <value>
        Removes the given value from the key which is an array.
CONFIG
      ;;
    check)
      cat <<CHECK
Usage:
  basin check

Description:
  This is the bread and butter of basin. It checks all services to see if
  channels you care about are online. It checks against a local database every
  time a check is performed; if the channel started streaming since the last
  check, or changes their game or status, then it triggers a notification.
CHECK
      ;;
    list)
      cat <<LIST
Usage:
  basin [-j] list

Description:
  This outputs a list of all live channels. If JSON output is active (-j),
  it will output them as a JSON array.
LIST
      ;;
    tui)
      cat <<TUI
Usage:
  basin tui

Description:
  This displays a text-based user interface in the terminal that shows who the
  local database says are currently online. This does not actively check for
  online streams, it simply shows the current state of the database in a
  friendly way. A regular instance of the script (basin check) needs to be run
  in a cron job or similar to keep the database fresh.
TUI
      ;;
    search)
      cat <<SEARCH
Usage:
  basin search game "<name>" ["<name>"...]
  basin search status "<string>" ["<string>"...]

Description:
  Allows to search for streams based on games or status. This will match any
  streams playing the list of games, or having the strings as their status.
  The first 10 matching streams (ordered by viewer count) are displayed.
  If JSON output is active (-j), it will output them as a JSON array.

Note:
  This will only search Twitch and Hitbox, since other services do not expose
  the necessary search functionality.
SEARCH
      ;;
    reset)
      cat <<RESET
Usage:
  basin reset

Description:
  Resets the local database to empty. This is useful if you want to retrigger
  notifications for all online channels on the next check or when developing.
RESET
      ;;
    start)
      cat <<START
Usage:
  basin start [minutes]

Description:
  Adds a crontab entry for basin that runs every minute. You can change the
  default number of minutes by giving start an argument that is a number greater
  than 1. Most service APIs discourage checking more often than once a minute.

See Also:
  stop, status
START
      ;;
    stop)
      cat <<STOP
Usage:
  basin stop

Description:
  Removes basin's crontab entry; thus making sure it is no longer running.

See Also:
  start, status
STOP
      ;;
    status)
      cat <<STATUS
Usage:
  basin status

Description:
  Checks to see if there is an entry for basin in crontab. This can be fooled
  into thinking basin is running by having a crontab entry for basin that is
  commented out. A simple fix for this is to run basin's stop and start commands
  to remove the entry and re-add it.

See Also:
  start, stop
STATUS
      ;;
    usage)
      cat <<USAGE
Usage:
  basin [options] command [subcommands]

Options:
  -c FILE         Use the specified config file instead of the default.
  -j              Use JSON instead of raw text output if applicable to the command.

Commands:
  help, usage, config, check, list, tui, reset, search, start, stop, status
USAGE
      ;;
    *) echo "No help entry for: ${1}" ;;
  esac
}
basin::check() { # call each service plugin, collect their data for database
  preflight
  new_online_db='[]'

  local service_call
  for service in $(config::enabled_keys .service); do
    service_call="service::${service}"
    ${service_call}
  done

  database::write "${new_online_db}"
}
basin::list() { # list live channels
  preflight
  if [[ "$OUTPUT_JSON" == "true" ]]
  then

    cat "${DATABASE_FILE}" | jq '(.online // [])'

  else

    database::print_formatted

  fi
}
basin::search() {

  if [[ $# -lt 2 ]]
  then
    error 'You have to specify a category and a search parameter!'
    return 1
  fi

  local type="${1}"

  shift

  local returned_data_twitch
  local returned_data_hitbox

  for arg
  do
    case ${type} in
      game)
        returned_data_twitch="$(curl -s \
          --header 'Client-ID: '${CLIENT} \
          -H 'Accept: application/vnd.twitchtv.v3+json' \
          --data-urlencode "game=${arg}" \
          -G "https://api.twitch.tv/kraken/streams?limit=10")"
        returned_data_hitbox="$(curl -s \
          --data-urlencode "game=${arg}" \
          -G "https://api.hitbox.tv/media/live/list?limit=10")"
        ;;
      status)
        returned_data_twitch="$(curl -s \
          --header 'Client-ID: '${CLIENT} \
          -H 'Accept: application/vnd.twitchtv.v3+json' \
          --data-urlencode "query=\"${arg}\"" \
          -G "https://api.twitch.tv/kraken/search/streams?limit=10")"
        returned_data_hitbox="$(curl -s \
          --data-urlencode "search=${arg}" \
          -G "https://api.hitbox.tv/media/live/list?limit=10")"
        ;;
      *)
        error '`basin search` can only search for `game` or `status`!'
        return 1
    esac

    local json_twitch
    local json_hitbox
    local json
    json_twitch="$(echo "${returned_data_twitch}" | jq -r '[
      .streams[] |
      {
        service: "Twitch",
        service_logo: "http://s.jtvnw.net/jtv_user_pictures/hosted_images/GlitchIcon_WhiteonPurple.png",
        name: .channel.name,
        display_name: .channel.display_name,
        game: .game,
        status: .channel.status,
        url: .channel.url,
        logo: .channel.logo,
        viewers: .viewers
      }
    ]')"
    json_hitbox="$(echo "${returned_data_hitbox}" | jq -r '[
      .livestream[] |
      {
        service: "Hitbox",
        service_logo: "http://i.imgur.com/ogo74T5.png",
        name: .media_name,
        display_name: .media_display_name,
        game: .category_name,
        status: .media_status,
        url: .channel.channel_link,
        logo: ("http://edge.sf.hitbox.tv" + .channel.user_logo),
        viewers: .media_views
      }
    ]')"

    json="$(echo "${json_twitch}" | jq -r ". + ${json_hitbox}" | jq -r ". | sort_by(.viewers | tonumber) | reverse [:10]")"

    if [[ "$OUTPUT_JSON" == "true" ]]
    then
      echo "${json}" | jq '.'
    else
      echo -e "$(echo "${json}" | jq -r '.[] |
        [
          "\n\\033[1;34m", .display_name, "\\033[0m",
          (
            # Properly align the game for shorter channel names
            .display_name | length |
            if . < 8 then
              "\t\t"
            else
              "\t"
            end
          ),
          "\\033[0;36m", .game, "\\033[0m\n",
          (.viewers | tostring), " @ \\033[0;32m", .url, "\\033[0m",
          "\n", .status
        ] |
        add')"
    fi

  done
}
basin::notify() { # determine if a channel merits notification, call notifier plugins
  local new_online_json="${1}" # JSON object parsed by service plugin
  local channel="${2}" # channel to check against service and db

  # check if stream is active
  local name
  name="$(json_get "${new_online_json}" "${channel}" 'name')"
  if [[ "${name}" == "${channel}" ]]; then
    # notify unless something says not to
    local notify=true

    # check if it has been active since last check
    if [[ -n "${DATABASE_FILE}" ]]; then
      local service dbcheck
      service="$(json_get "${new_online_json}" "${channel}" 'service')"
      dbcheck="$(database::get ${service} ${name} 'name')"

      # already streaming last time, check for updates
      if [[ -n "${dbcheck}" ]]; then
        notify=false
        local dbgame dbstatus sgame sstatus
        dbgame="$(database::get ${service} ${name} 'game')"
        dbstatus="$(database::get ${service} ${name} 'status')"
        sgame="$(json_get "${new_online_json}" "${channel}" 'game')"
        sstatus="$(json_get "${new_online_json}" "${channel}" 'status')"
        # notify when game or status change
        if [[ "${dbgame}" != "${sgame}" || "${dbstatus}" != "${sstatus}" ]]; then
          notify=true
        fi
      fi
    fi

    if [[ ${notify} == true ]]; then
      local notifier_call
      for notifier in $(config::enabled_keys .notifier); do
        notifier_call="notifier::${notifier}"
        ${notifier_call} "$(json_get "${new_online_json}" "${channel}")"
      done
    fi
  fi
}
basin::tui() { # display DB items using a text-based user interface
  # Thanks a lot to: http://stackoverflow.com/a/27946484

  tui_cleanup() { # exit interactive mode gracefully
    # revert black magic, exit the screen and recover old cursor position
    stty sane
    # exit the screen and recover old cursor position at this point, all changes
    # done by our script should be reverted
    tput rmcup
  }

  tui_display() { # generate the output for the interactive menu
    tput clear

    database::load
    local last_checked
    last_checked=$(cat ${DATABASE_FILE} | jq -r '.lastcheck // 0')
    if [[ ${last_checked} -eq 0 ]]; then
      error "Database is stale. Try updating with: basin check"
    else
      # print the header
      echo -n "Streams currently live: (last checked at "
      system_date "${last_checked}"
      echo "[press q to exit]"

      # pretty-print the database json
      database::print_formatted
      echo
    fi
  }

  preflight
  # enables deletion of output, and sets the read timeout so we have immediate
  # reactions
  stty -icanon time 0 min 0
  # saves current position of the cursor, and opens new screen
  tput smcup
  # let's start by displaying our data
  tui_display

  # We have to constantly run the loop to give a fast reaction should the user
  # want to quit, but we do not want to constantly update the output. Let's keep
  # track of how many iterations there were and only update every 25 * 0.4 = 10
  # seconds.
  local i=0

  local keypress=''
  # run the loop until [q] is pressed
  while [[ "${keypress}" != "q" ]]; do
    # we need some kind of timeout so we don't waste cpu time
    sleep 0.4
    # make sure to only update every ten seconds
    ((i+=1))
    if [[ ${i} -eq 25 ]]; then
      # output our stuff
      tui_display
      i=0
    fi
    # If a button is pressed, read it. Since we set the minimum read length to 0
    # using stty, we do not wait for an input here but also accept empty input
    # (i.e. no keys pressed).
    read keypress

    # handle ctrl-c (SIGINT) gracefully and restore the proper prompt
    trap tui_cleanup SIGINT
  done

  # reset and exit
  tui_cleanup
}

### Main Function
main() {
  depends_on jq
  depends_on curl

  while getopts ":c:jh" opt; do
    case ${opt} in
      c) ALT_CONFIG="${OPTARG}" ;;
      j) OUTPUT_JSON="true" ;;
      h) basin::help usage; exit 0 ;;
      \?) error "Invalid option: -${OPTARG}"; exit 1 ;;
      :) error "-${OPTARG} requires an argument."; exit 1 ;;
    esac
  done
  shift $((OPTIND-1))

  case ${1} in
    check) basin::check ;;
    config) shift; config::do "${@}" ;;
    list) basin::list ;;
    search) basin::search "${@:2}" ;;
    tui) basin::tui ;;
    reset) config::load && database::reset ;;
    start) shift; crontab::start "${@}" ;;
    stop) crontab::stop ;;
    status) crontab::status ;;
    help) shift; basin::help "${@}" ;;
    *|usage) basin::help usage ;;
  esac
}
main "${@}"
