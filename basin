#!/usr/bin/env bash
# basin - all the streams you care about in once place
# by BrowncoatShadow and Crendgrim
# https://github.com/BrowncoatShadow/basin

### Helper Functions
check_system() { # platform specific fixes and function definitions
  local system_type
  system_type="$(uname)"
  if [[ "${system_type}" == "Darwin" ]]; then # OS X
    # add jq's install dir (via homebrew) to PATH.
    PATH=${PATH}:/usr/local/bin
    # helper for interactive mode, returns the given time using system's `date`
    system_date() { echo "$(date -jf %s "${1}" "+%H:%M"))"; }
  elif [[ "${system_type}" == "Linux" ]]; then # Linux
    system_date() { echo "$(date --date="@${1}" "+%H:%M"))"; }
  else # unknown system
    error "${system_type} is not supported."
    exit 1
  fi
}
error() { # print a colorful message to STDERR
  local red='\033[0;31m'
  local nc='\033[0m'
  echo -e "${red}[ERROR] ${1}${nc}" >&2
}
depends_on() { # check for a given dependency, exit if missing
  command -v ${1} > /dev/null
  if [[ "$?" == "1" ]]; then
    error "Missing dependency: ${1}"
    exit 1
  fi
}
load_config() { # load configuration from file # check if alternative config file is defined
  if [[ -n "${ALT_CONFIG}" ]]; then
    # if the config file does not exist yet, exit with a descriptive error message
    if [[ ! -f "${ALT_CONFIG}" ]]; then
      error "The specified configuration file ${ALT_CONFIG} is missing."
      error "You can create it by copying the default configuration file at \`${HOME}/.config/basinrc\`."
      error "If that file does not exist, you can create it by running: basin init"
      exit 1
    fi

    # use alt config file if defined
    CFGFILE="${ALT_CONFIG}"
  else
    # if the config file does not exist yet, exit with a descriptive error message
    if [[ ! -f "${HOME}/.config/basinrc" ]]; then
      error "The default configuration file ${HOME}/.config/basinrc is missing."
      error "You can create it by running: basin init"
      exit 1
    fi

    # use default config file
    CFGFILE="${HOME}/.config/basinrc"
  fi

  # load config file
  source "${CFGFILE}"
}
init_config() { # generate a default configuration file
  # if the file exists already, ask the user if he really wants to replace it
  if [[ -f "${HOME}/.config/basinrc" ]]; then
    local prompt_string="The configuration file \`${HOME}/.config/basinrc\` exists already. Are you sure you want to replace it? [y/N] "
    read -p "${prompt_string}"
    if [[ ! "${REPLY}" =~ ^[yY].* ]]; then
      echo "Aborting config file creation..."
      return 0
    fi
  fi
  # Generate default basinrc.
  cat > "${HOME}/.config/basinrc" <<"CONFIG"
#!/bin/bash
# basinrc - Configuration file for basin.
# by BrowncoatShadow and Crendgrim
# <https://github.com/BrowncoatShadow/basin>


### GENERAL SETTINGS
# DBFILE - The database file for storing currently online streams.
#	default: DBFILE=${HOME}/.local/share/basin/online.json
# DEBUGFILE - The file for storing debug data. This can help to debug the script itself.
#	NOTE: This functionality is currently broken.
#	default: DEBUGFILE=${HOME}/.local/share/basin/debug.json
# NOTIFIER - The notification plugin to use.
#	default: MODULE=echo
DBFILE=${HOME}/.local/share/basin/online.json
DEBUGFILE=${HOME}/.local/share/basin/debug.json
NOTIFIER=echo


### SERVICE SETTINGS
# Settings for the various streaming services to check.

### TWITCH SETTINGS
# TWITCH_USER - Your Twitch user in all lower-case letters. If set, use this user's followed channels.
#	default: TWITCH_USER=
# TWITCH_FOLLOWLIST - Additional list of streams to check on, divided by spaces.
#	default: TWITCH_FOLLOWLIST=""
# TWITCH_CLIENT_ID - Twitch client_id, generate at <http://www.twitch.tv/kraken/oauth2/clients/new>.
#	default: TWITCH_CLIENT_ID=
TWITCH_USER=
TWITCH_FOLLOWLIST=""
TWITCH_CLIENT_ID=

### HITBOX SETTINGS
# HITBOX_USER - Your Hitbox user in all lower-case letters. If set, use this user's followed channels.
#	default: HITBOX_USER=
# HITBOX_FOLLOWLIST - Additional list of streams to check on, divided by spaces.
#	default: HITBOX_FOLLOWLIST=""
HITBOX_USER=
HITBOX_FOLLOWLIST=""

### AZUBU SETTINGS
# AZUBU_FOLLOWLIST - List of streams to check on, divided by spaces.
# default: AZUBU_FOLLOWLIST=""
AZUBU_FOLLOWLIST=""

### PERISCOPE SETTINGS
# PERISCOPE_FOLLOWLIST - List of streams to check on, divided by spaces.
# default: PERISCOPE_FOLLOWLIST=""
PERISCOPE_FOLLOWLIST=

### YOUTUBE SETTINGS
# YOUTUBE_KEY - (Required) Youtube API key with "YouTube Data API v3" enabled.
# YOUTUBE_FOLLOWLIST - List of youtube users whose channels's to check on, devices by spaces.
YOUTUBE_KEY=""
YOUTUBE_FOLLOWLIST=""


### NOTIFIER SETTINGS
# Settings for the user-visable notifications for changes to a stream status.

### PUSHBULLET SETTINGS
# Note: If PB_URLTARGET and PB_URITARGET are unset, the module will send to all targets.
#
# PB_TOKEN - Pushbullet access token. Find at <https://www.pushbullet.com/account>
#	default: PB_TOKEN=
# PB_TARGET - Space seperated list of pushbullet device_idens to send the notification to. If this is not set, notification will be sent to all devices.
#	default: PB_TARGET=""
PB_TOKEN=
PB_TARGET=""
CONFIG
  # TODO Is this best practice?
  # open the new basinrc with the users ${EDITOR}, so they can configure it
  ${EDITOR} "${HOME}/.config/basinrc"
}
check_file() { # generate given folders and files if they do not exist
  if [[ ! -f ${1} ]]; then
    mkdir -p $(dirname ${1})
    touch ${1}
  fi
  if [[ -z $(cat ${1}) ]]; then
    echo ${2} > ${1}
  fi
}
json_get() { # get channel data from an array of channel objects
  echo "${1}" | jq -r '.[] | select(.name=="'${2}'") | .'${3}
}
chan_get() { # get a value from a channel object
  echo "${1}" | jq -r ".${2} | select(.!=null)"
}
playing_check() { # return null if given game is null, return given "playing" string if it is not
  if [[ -n "${1}" ]]; then
    echo "${2}"
  fi
}
preflight() { # handles all common tasks that should be taken before normal operations
  check_system
  load_config
  database::health
}

### Crontab
# Functions that manage basin's crontab entry.
crontab::running() { # check if entry already exists in crontab
  depends_on crontab

  # this can be fooled by basin's entry being commented out
  if crontab -l 2> /dev/null | grep -Fq 'basin check'; then
    true
  else
    false
  fi
}
crontab::status() { # prints basin's status to terminal
  if crontab::running; then
    echo "Basin is running."
  else
    echo "Basin is not running."
  fi
}
crontab::start() { # create basin's crontab entry
  if crontab::running; then
    error "Basin is already running."
    exit 1
  fi
  # if given an argument, use it as the number of minutes between checks
  local minutes
  if [[ "${1}" ]]; then
    if [[ ! "${1}" =~ ^[0-9]+$ || "${1}" -lt 1  ]]; then
      error "Minutes for 'start' need to be a number, greater than 1."
    else
      minutes="${1}"
    fi
  else
    minutes=1
  fi
  local source_dir
  source_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
  local entry="*/${minutes} * * * * ${source_dir}/basin check >/dev/null 2>&1"

  # list crontab, concat that output with basin's entry, feed back to crontab
  EDITOR=cat crontab -e 2> /dev/null | { cat; echo "${entry}"; } | crontab -
}
crontab::stop() { # remove basin's crontab entry
  if ! crontab::running; then
    return
  fi

  # list crontab, remove basin's entry, feed back to crontab
  EDITOR=cat crontab -e 2> /dev/null | sed '/basin check/d' | crontab -
}

### Database
# Functions that handle the local database.
database::get() { # get data from the database
  cat "${DBFILE}" \
    | jq -r '(.online // [])[] | select(.service=="'${1}'" and .name=="'${2}'") | .'${3}
}
database::include() { # add arrayed online channel objects to global list to be added to db
  # update the global with entries if they exist
  if [[ -n "${1}" ]]; then
    new_online_db="$(echo "${new_online_db}" | jq ". + ${1}")"
  fi
}
database::write() { # save given json object to the DBFILE
  if [[ -n "${DBFILE}" ]]; then
    echo "${1}" \
      | jq '{online: ., lastcheck: '$(date +%s)'}' > ${DBFILE}
  fi
}
database::recover() { # recover an existing DB entry for broken API results
  local service="${1}"
  local json="${2}"
  local channel="${3}"
  # recover existing db entry if it exists
  local recovered_data
  recovered_data="$(database::get "${service}" ${channel})"
  if [[ -n "${recovered_data}" ]]; then
    # remove entry
    json="$(echo "${json}" \
      | jq 'del(.[] | select(.name=="'${channel}'"))')"
    # return a fixed JSON object
    echo "${json}" | jq '. + ['"${recovered_data}"']'
  else
    echo "${json}"
  fi
}
database::health() { # makes sure the DB file exists and is not too old
  check_file "${DBFILE}" "{}"
  # cleanup: if the database file is older than 2 hours, consider it outdated
  # and remove its contents
  [[ -s "${DBFILE}" && $(($(date +%s)-$(cat "${DBFILE}" | jq -r '.lastcheck // 0'))) -gt 7200 ]] && database::reset
}
database::reset() { # wipes the database clean
  echo "{}" > "${DBFILE}"
}
database::print_formatted() { # pretty-prints the database
  echo -e "$(cat "${DBFILE}" | jq -r '
    .online[] |
      [
        "\n\\033[1;34m", .display_name, "\\033[0m",
        (
          # Properly align the game for shorter channel names
          .display_name | length |
          if . < 8 then
            "\t\t"
          else
            "\t"
          end
        ),
        "\\033[0;36m", .game, "\\033[0m",
        "\n\\033[0;32m", .url, "\\033[0m",
      "\n", .status
      ] |
    add')"
}

### Notifier Plugins
# Plugins that provide user-visible notifications.
notifier::echo() { # notify by printing to STDOUT in the terminal
  local service display_name game status url playing
  service="$(chan_get "${1}" 'service')"
  display_name="$(chan_get "${1}" 'display_name')"
  status="$(chan_get "${1}" 'status')"
  url="$(chan_get "${1}" 'url')"
  game="$(chan_get "${1}" 'game')"
  playing="$(playing_check "${game}" " playing ${game}")"

  echo "${service} | ${display_name}${playing} | ${status} | ${url}"
}
notifier::kdialog() { # notify by KDialog popup
  local service display_name game status
  service="$(chan_get "${1}" 'service')"
  display_name="$(chan_get "${1}" 'display_name')"
  status="$(chan_get "${1}" 'status')"
  game="$(chan_get "${1}" 'game')"
  playing="$(playing_check "${game}" " playing <b>${game}</b>")"

  display="$DISPLAY"
  if [[ -z "$display" ]]; then display=":0"; fi
  DISPLAY="$display" kdialog \
    --title "${service}" \
    --icon "video-player" \
    --passivepopup "<b>${display_name}</b>${playing}<br>${status}"
}
notifier::osx() { # OS X Notification Center with applescript
  local service display_name game status
  service="$(chan_get "${1}" 'service')"
  display_name="$(chan_get "${1}" 'display_name')"
  status="$(chan_get "${1}" 'status')"
  game="$(chan_get "${1}" 'game')"
  playing="$(playing_check "${game}" " playing ${game}")"

  osascript \
    -e "display notification \"${status}\" \
    with title \"${service}\" \
    subtitle \"${display_name}${playing}\""
}
notifier::terminal_notifier() { # OS X Notification Center with terminal-notifier
  local service display_name game status url
  service="$(chan_get "${1}" 'service')"
  service_logo="$(chan_get "${1}" 'service_logo')"
  logo="$(chan_get "${1}" 'logo')"
  display_name="$(chan_get "${1}" 'display_name')"
  status="$(chan_get "${1}" 'status')"
  url="$(chan_get "${1}" 'url')"
  game="$(chan_get "${1}" 'game')"
  playing="$(playing_check "${game}" " playing ${game}")"

  tn_sanitize() { # escape characters known to cause issues at the beginning of strings
    local escape='[<'
    echo "${1}" | sed "s/^[${escape}]/\\\&/"
  }

  terminal-notifier \
    -title "${service}" \
    -subtitle "${display_name}${playing}" \
    -message "$(tn_sanitize "${status}")" \
    -appIcon "${service_logo}" \
    -contentImage "${logo}" \
    -open "${url}" \
    >/dev/null # silently fail instead of printing useage
}
notifier::pushbullet() { # notify by PushBullet API notification
  # make sure we have a token
  if [[ -z "${PB_TOKEN}" ]]; then
    error "You need to set PB_TOKEN in your settings file."
    exit 1
  fi
  local service display_name game status url
  service="$(chan_get "${1}" 'service')"
  display_name="$(chan_get "${1}" 'display_name')"
  status="$(chan_get "${1}" 'status')"
  url="$(chan_get "${1}" 'url')"
  game="$(chan_get "${1}" 'game')"
  playing="$(playing_check "${game}" " playing ${game}")"

  # function to send pushes
  push() {
    local data
    data='{
      "device_iden": "'"${1}"'",
      "type": "link",
      "title": "'"${service}"'",
      "body": "'"${display_name}${playing}\\n${status}"'",
      "url": "'"${url}"'"
    }'
    curl -s \
      -X POST https://api.pushbullet.com/v2/pushes \
      --header 'Access-Token: '${PB_TOKEN}'' \
      --header 'Content-Type: application/json' \
      --data-binary "${data}" \
      > /dev/null
  }

  # push to any targets that are defined
  if [[ -n "${PB_TARGET}" ]]; then
    for target in ${PB_TARGET}; do
      push ${target}
    done
  else # if no targets, push to all
    push
  fi
}

### Service Plugins
# Plugins that provide support for a particular streaming service.
service::twitch() { # https://www.twitch.tv/
  if [[ -z "${TWITCH_USER}" && -z "${TWITCH_FOLLOWLIST}" ]]; then
    return 0 # nothing to check
  fi
  # use the specified followlist, if set
  local twitch_list=${TWITCH_FOLLOWLIST}

  # if user is set, fetch user's follow list and add them to the list
  if [[ -n ${TWITCH_USER} ]]; then 
    twitch_list="${twitch_list} \
      "$(curl -s \
      --header 'Client-ID: '${TWITCH_CLIENT_ID} \
      -H 'Accept: application/vnd.twitchtv.v3+json' \
      -X GET "https://api.twitch.tv/kraken/users/${TWITCH_USER}/follows/channels?limit=100" \
      | jq -r '.follows[] | .channel.name' \
      | tr '\n' ' ')
  fi

  # remove duplicates from the list
  twitch_list=$(echo $(printf '%s\n' ${twitch_list} | sort -u))

  # sanitize the list for the fetch url
  local url_list
  url_list="$(echo ${twitch_list} | sed 's/ /\,/g')"

  # fetch the json for all followed channels
  local returned_data
  returned_data="$(curl -s \
    --header 'Client-ID: '${CLIENT} \
    -H 'Accept: application/vnd.twitchtv.v3+json' \
    -X GET "https://api.twitch.tv/kraken/streams?channel=${url_list}&limit=100")"

  # create new database
  local new_online_json
  new_online_json="$(echo "${returned_data}" | jq '
    [
      .streams[] |
        {
          service: "Twitch",
          service_logo: "http://s.jtvnw.net/jtv_user_pictures/hosted_images/GlitchIcon_WhiteonPurple.png",
          name: .channel.name,
          display_name: .channel.display_name,
          game: .channel.game,
          status: .channel.status,
          url: .channel.url,
          logo: .channel.logo
        }
    ]')"

  # notify for new streams
  for channel in ${twitch_list}; do
    # sometimes, the api sends broken results handle these gracefully
    local check_game check_status
    check_game="$(json_get "${new_online_json}" "${channel}" 'game')"
    check_status="$(json_get "${new_online_json}" "${channel}" 'status')"
    if [[ "${check_game}" == null && "${check_status}" == null ]]; then
      # if the stream was live before, assume the results to be broken, so we
      # don't re-notify
      if [[ -n "${DBFILE}" ]]; then
        # recover existing db entry if it exists
        new_online_json="$(database::recover "${service}" "${new_online_json}" "${channel}")"
      fi
      # otherwise ignore the broken result to not get a null/null notification
      continue
    fi

    # if result is not broken, send it to notifier gateway
    basin::notify "${new_online_json}" "${channel}"
  done

  database::include "${new_online_json}"
}
service::hitbox() { # http://www.hitbox.tv/
  if [[ -z "${HITBOX_USER}" && -z "${HITBOX_FOLLOWLIST}" ]]; then
    return 0 # nothing to check
  fi
  # use the specified followlist, if set
  local hitbox_list="${HITBOX_FOLLOWLIST}"
  # if user is set, fetch user's follow list and add them to the list
  if [[ -n "${HITBOX_USER}" ]]; then
    hitbox_list="${hitbox_list} \
    "$(curl -s \
    -X GET "https://api.hitbox.tv/following/user/?user_name=${HITBOX_USER}" \
    | jq -r '.following[] | .user_name' \
    | tr '\n' ' ')
  fi

  # remove duplicates from the list
  hitbox_list=$(echo $(printf '%s\n' ${hitbox_list} | sort -u))

  # fetch the json for all followed channels
  local new_online_json='[]'
  for channel in ${hitbox_list}; do
    local returned_data
    returned_data="$(curl -s -X GET "https://api.hitbox.tv/media/live/${channel}")"

    # sometimes the hitbox api returns garbage if that happens, handle it gracefully
    local is_live
    is_live="$(echo "${returned_data}" \
      | jq -r '.livestream[] | .media_is_live' \
      2>/dev/null)"

    if [[ $? == 4 ]]; then
      # insert entry recovered from database
      if [[ -n "${DBFILE}" ]]; then
        # recover existing db entry if it exists
        new_online_json="$(database::recover "${service}" "${new_online_json}" "${channel}")"
      fi

    elif [[ "${is_live}" == "1" ]]; then
      # insert into new database
      new_online_json="$(echo "${returned_data}" \
        | jq "${new_online_json}"' +
        [
          .livestream[] |
          {
            service: "Hitbox",
            service_logo: "http://i.imgur.com/ogo74T5.png",
            name: .media_name,
            display_name: .media_display_name,
            game: .category_name,
            status: .media_status,
            url: .channel.channel_link,
            logo: ("http://edge.sf.hitbox.tv" + .channel.user_logo)
          }
        ]')"
    fi
  done

  # notify for new streams
  for channel in ${hitbox_list}; do
    basin::notify "${new_online_json}" ${channel,,}
  done

  database::include "${new_online_json}"
}
service::azubu() { # http://www.azubu.tv/
  if [[ -z "${AZUBU_FOLLOWLIST}" ]]; then
    return 0 # nothing to check
  fi
  # remove duplicates from the list
  local azubu_list
  azubu_list=$(echo $(printf '%s\n' ${AZUBU_FOLLOWLIST} | sort -u))
  # sanitize the list for the fetch url
  local url_list
  url_list=$(echo ${azubu_list} | sed 's/ /\,/g')
  # fetch the json for all followed channels
  local returned_data
  returned_data="$(curl -s \
    -X GET "http://api.azubu.tv/public/channel/list?channels=${url_list}")"

  # create new database
  local new_online_json
  new_online_json="$(echo "${returned_data}" \
    | jq '
    [
      .data [] |
      select(.is_live == true) |
      {
        service: "Azubu",
        service_logo: "http://cdn.content.azubu.tv.s3.amazonaws.com/assets/images/azubu_placeholder.png",
        name: .user.username,
        display_name: .user.display_name,
        game: .category.title,
        status: .title,
        url: .url_channel,
        logo: .user.profile.url_photo_large
      }
    ]')"

  # notify for new streams
  for channel in ${azubu_list}; do
    basin::notify "${new_online_json}" ${channel}
  done

  database::include "${new_online_json}"
}
service::periscope() { # https://www.periscope.tv/
  if [[ -z "${PERISCOPE_FOLLOWLIST}" ]]; then
    return 0 # nothing to check
  fi

  # remove duplicates from the list
  PERISCOPE_FOLLOWLIST=$(echo $(printf '%s\n' ${PERISCOPE_FOLLOWLIST} | sort -u))

  local new_online_json='[]'
  for channel in ${PERISCOPE_FOLLOWLIST}; do

    local raw_html
    raw_html="$(curl -s https://www.periscope.tv/${channel})"
    # Periscope's API is private. However, user pages have a meta tag with an
    # HTML entity-encoded JSON string that contains everything we want to know.
    # After fetching the user page, we have to get everything in the
    # broadcast-data meta tag's value, then decode the HTML entities we know it
    # commonly uses. End result: a JSON string we would expect from an API.
    local broadcast_data
    broadcast_data="$(echo "${raw_html}" \
      | sed -n 's/.*meta id=\"broadcast-data\" content=\"\(.*\)"><meta id=\"broadcast-in-app\".*/\1/p' \
      | sed -e 's/\&quot;/"/g' \
            -e 's/\&amp;/\&/g' )"

    # check if the channel is broadcasting
    local is_running
    is_running="$(echo ${broadcast_data} \
      | jq 'select(.broadcast.state=="RUNNING")' 2>/dev/null)"
    if [[ -n "${is_running}" ]]; then
      new_online_json="$(echo "${broadcast_data}" \
        | jq "${new_online_json}"' +
        [
          .broadcast |
          {
            service: "Periscope",
            service_logo: "https://www.periscope.tv/v/images/press_assets/largeicon.png",
            name: .username,
            display_name: .user_display_name,
            game: .class_name,
            status: .status,
            url: ("https://www.periscope.tv/" + .username),
            logo: .profile_image_url
          }
        ]')"
    fi
  done

  # notify for new streams
  for channel in ${PERISCOPE_FOLLOWLIST}; do
    basin::notify "${new_online_json}" ${channel}
  done

  database::include "${new_online_json}"
}
service::youtube() { # https://www.youtube.com/
  if [[ -z "${YOUTUBE_FOLLOWLIST}" ]]; then
    return 0 # nothing to check
  fi
  if [[ -z "${YOUTUBE_KEY}" ]]; then
    error "You need to set YOUTUBE_KEY in your settings file."
    return 1
  fi

  # remove duplicates from the list
  YOUTUBE_FOLLOWLIST=$(echo $(printf '%s\n' ${YOUTUBE_FOLLOWLIST} | sort -u))

  # define some api url strings
  local yt_api="https://www.googleapis.com/youtube/v3/"
  local yt_user_search="${yt_api}channels?part=snippet&key=${YOUTUBE_KEY}&forUsername="
  local yt_live_search="${yt_api}search?part=snippet&eventType=live&type=video&key=${YOUTUBE_KEY}&channelId="

  local new_online_json='[]'
  for channel in ${YOUTUBE_FOLLOWLIST}; do
    # get the channel id for a youtube user
    local user_data="$(curl -s -X GET ${yt_user_search}${channel})"
    local chan_id
    chan_id="$(echo "${user_data}" | jq -r '.items[0].id')"

    local broadcast_data
    broadcast_data="$(curl -s -X GET ${yt_live_search}${chan_id})"

    # check if the channel is broadcasting
    local broadcast_status
    broadcast_status="$(echo ${broadcast_data} \
      | jq -r '.items[0].snippet.liveBroadcastContent' 2>/dev/null)"
    if [[ "${broadcast_status}" == "live" ]]; then
      local chan_logo
      chan_logo="$(echo "${user_data}" | jq -r '.items[0].snippet.thumbnails.high.url')"
      new_online_json="$(echo "${broadcast_data}" \
        | jq "${new_online_json}"' +
        [
          .items[0] |
          {
            service: "YouTube",
            service_logo: "https://www.youtube.com/yt/brand/media/image/YouTube-icon-full_color.png",
            name: "'"${channel}"'",
            display_name: .snippet.channelTitle,
            status: .snippet.title,
            url: ("https://www.youtube.com/watch?v=" + .id.videoId),
            logo: "'"${chan_logo}"'"
          }
        ]')"
    fi
  done

  # notify for new streams
  for channel in ${YOUTUBE_FOLLOWLIST}; do
    basin::notify "${new_online_json}" ${channel}
  done

  database::include "${new_online_json}"
}

### Basin Core
# The core functionality for basin.
basin::help() { # be helpful
  case "${1}" in
    help)
      cat <<HELP
Useage:
  basin help [command]

Description:
  Help will desscribe commands and how they can be used.

See Also:
  useage
HELP
      ;;
    init)
      cat <<INIT
Useage:
  basin init

Description:
  Creates a new configuration file at ~/.config/basinrc, and opens it in the
  user's EDITOR to be customized.
INIT
      ;;
    check)
      cat <<CHECK
Useage:
  basin check

Description:
  This is the bread and butter of basin. It checks all services to see if
  channels you care about are online. It checks against a local database every
  time a check is performed; if the channel started streaming since the last
  check, or changes their game or status, then it triggers a notification.
CHECK
      ;;
    list)
      cat <<LIST
Usage:
  basin [-j] list

Description:
  This outputs a list of all live channels. If JSON output is active (-j),
  it will output them as a JSON array.
LIST
      ;;
    tui)
      cat <<TUI
Useage:
  basin tui

Description:
  This displays a text-based user interface in the terminal that shows who the
  local database says are currently online. This does not actively check for
  online streams, it simply shows the current state of the database in a
  friendly way. A regular instance of the script (basin check) needs to be run
  in a cron job or similar to keep the database fresh.
TUI
      ;;
    reset)
      cat <<RESET
Useage:
  basin reset

Description:
  Resets the local database to empty. This is useful if you want to retrigger
  notifications for all online channels on the next check or when developing.
RESET
      ;;
    start)
      cat <<START
Useage:
  basin start [minutes]

Description:
  Adds a crontab entry for basin that runs every minute. You can change the
  default number of minutes by giving start an argument that is a number greater
  than 1. Most service APIs discourage checking more often than once a minute.

See Also:
  stop, status
START
      ;;
    stop)
      cat <<STOP
Useage:
  basin stop

Description:
  Removes basin's crontab entry; thus making sure it is no longer running.

See Also:
  start, status
STOP
      ;;
    status)
      cat <<STATUS
Useage:
  basin status

Description:
  Checks to see if there is an entry for basin in crontab. This can be fooled
  into thinking basin is running by having a crontab entry for basin that is
  commented out. A simple fix for this is to run basin's stop and start commands
  to remove the entry and re-add it.

See Also:
  start, stop
STATUS
      ;;
    useage)
      cat <<USEAGE
Useage:
  basin [options] command [subcommands]

Options:
  -c FILE         Use the specified config file instead of the default.
  -j              Use JSON instead of raw text output if applicable to the command.

Commands:
  help, useage, check, list, tui, reset, start, stop, status
USEAGE
      ;;
    *) echo "No help entry for: ${1}" ;;
  esac
}
basin::init() { # initialize environment
  init_config
  crontab::start
  exit 0
}
basin::check() { # call each service plugin, collect their data for database
  preflight
  new_online_db='[]'

  service::twitch
  service::hitbox
  service::azubu
  service::periscope
  service::youtube

  database::write "${new_online_db}"
}
basin::list() { # list live channels
  preflight
  if [[ "$OUTPUT_JSON" == "true" ]]
  then

    cat "${DBFILE}" | jq '(.online // [])'

  else

    database::print_formatted

  fi
}
basin::notify() { # determine if a channel merits notification, call notifier plugins
  local new_online_json="${1}" # JSON object parsed by service plugin
  local channel="${2}" # channel to check against service and db

  # check if stream is active
  local name
  name="$(json_get "${new_online_json}" "${channel}" 'name')"
  if [[ "${name}" == "${channel}" ]]; then
    # notify unless something says not to
    local notify=true

    # check if it has been active since last check
    if [[ -n "${DBFILE}" ]]; then
      local service dbcheck
      service="$(json_get "${new_online_json}" "${channel}" 'service')"
      dbcheck="$(database::get ${service} ${name} 'name')"

      # already streaming last time, check for updates
      if [[ -n "${dbcheck}" ]]; then
        notify=false
        local dbgame dbstatus sgame sstatus
        dbgame="$(database::get ${service} ${name} 'game')"
        dbstatus="$(database::get ${service} ${name} 'status')"
        sgame="$(json_get "${new_online_json}" "${channel}" 'game')"
        sstatus="$(json_get "${new_online_json}" "${channel}" 'status')"
        # notify when game or status change
        if [[ "${dbgame}" != "${sgame}" || "${dbstatus}" != "${sstatus}" ]]; then
          notify=true
        fi
      fi
    fi

    if [[ ${notify} == true ]]; then
      # send notification by using the module and giving it the arguments
      local notifier="notifier::${NOTIFIER}"
      ${notifier} "$(json_get "${new_online_json}" "${channel}")"
    fi
  fi
}
basin::tui() { # display DB items using a text-based user interface
  # Thanks a lot to: http://stackoverflow.com/a/27946484

  tui_cleanup() { # exit interactive mode gracefully
    # revert black magic, exit the screen and recover old cursor position
    stty sane
    # exit the screen and recover old cursor position at this point, all changes
    # done by our script should be reverted
    tput rmcup
    # end the script here, don't query the API at all
    exit 0
  }

  tui_display() { # generate the output for the interactive menu
    tput clear

    database::health
    local last_checked
    last_checked=$(cat ${DBFILE} | jq -r '.lastcheck // 0')
    if [[ ${last_checked} -eq 0 ]]; then
      error "Database is stale. Try updating with: basin check"
      exit 1
    fi

    # print the header
    echo -n "Streams currently live: (last checked at "
    system_date "${last_checked}"
    echo "[press q to exit]"

    # pretty-print the database json
    database::print_formatted
    echo
  }

  preflight
  # enables deletion of output, and sets the read timeout so we have immediate
  # reactions
  stty -icanon time 0 min 0
  # saves current position of the cursor, and opens new screen
  tput smcup
  # let's start by displaying our data
  tui_display

  # We have to constantly run the loop to give a fast reaction should the user
  # want to quit, but we do not want to constantly update the output. Let's keep
  # track of how many iterations there were and only update every 25 * 0.4 = 10
  # seconds.
  local i=0

  local keypress=''
  # run the loop until [q] is pressed
  while [[ "${keypress}" != "q" ]]; do
    # we need some kind of timeout so we don't waste cpu time
    sleep 0.4
    # make sure to only update every ten seconds
    ((i+=1))
    if [[ ${i} -eq 25 ]]; then
      # output our stuff
      tui_display
      i=0
    fi
    # If a button is pressed, read it. Since we set the minimum read length to 0
    # using stty, we do not wait for an input here but also accept empty input
    # (i.e. no keys pressed).
    read keypress

    # handle ctrl-c (SIGINT) gracefully and restore the proper prompt
    trap tui_cleanup SIGINT
  done

  # reset and exit
  tui_cleanup
}

### Main Function
main() {
  depends_on jq
  depends_on curl

  while getopts ":c:jh" opt; do
    case ${opt} in
      c) ALT_CONFIG="${OPTARG}" ;;
      j) OUTPUT_JSON="true" ;;
      h) basin::help useage; exit 0 ;;
      \?) error "Invalid option: -${OPTARG}"; exit 1 ;;
      :) error "-${OPTARG} requires an argument."; exit 1 ;;
    esac
  done
  shift $((OPTIND-1))

  case ${1} in
    init) basin::init ;;
    check) basin::check ;;
    list) basin::list ;;
    tui) basin::tui ;;
    reset) load_config && database::reset ;;
    start) shift; crontab::start "${@}" ;;
    stop) crontab::stop ;;
    status) crontab::status ;;
    help) shift; basin::help "${@}" ;;
    *|useage) basin::help useage ;;
  esac
}
main "${@}"
